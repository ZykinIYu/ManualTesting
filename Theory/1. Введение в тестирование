Тестирование программного обеспечения - проверка соответствия между реальным и ожидаемым поведением программы, осуществляемая на конечном наборе тестов, 
выбранном определенным образом. 
В более широком смысле, тестирование - это одна из техник контроля качества, включающая в себя активности по планированию работ, проектированию тестов, 
выполнению тестирования и анализу полученных результатов.
Верификация - это процесс оценки системы или её компонентов с целью определения удовлетворяют ли результаты текущего этапа разработки условиям, 
сформированным в начале этого этапа. Т.е. выполняются ли наши цели, сроки, задачи по разработке проекта, определенные в начале текущей фазы.

Подходы к формулированию стратегии тестирования:
1. Определить объемы тестовых работ путем анализа документов, содержащих требования к программному продукту (технические условия), чтобы выяснить, что нужно тестировать. 
Рассмотреть виды тестирования, которые не следуют непосредственно из документов с требованиями, такие как тестирование возможности установки и наращивания 
возможностей программного продукта, удобство и простота обслуживания продукта, а также способности к взаимодействию с другими видами аппаратных средств из 
среды заказчика.
2. Определить подход к тестированию за счет выбора статических и динамических тестов, связанных с каждой стадией разработки. 
Здесь потребуется включить описания всех рабочих продуктов, которые должна подготовить тестовая группа.
3. Определить критерии входа и выхода для каждой стадии тестирования, равно как и все точки контроля качества, для чего потребуется участие специалистов по тестированию.
4. Определить стратегию автоматизации в случае, если планируется использование автоматизации какого-либо вида тестовой деятельности. 
Автоматизация требует проведения независимых параллельных работ, которые должны тщательно планироваться и выполняться только в тех случаях, 
когда это не приводит к снижению эффективности.

Цели тестирования:
1. Повысить вероятность того, что приложение, предназначенное для тестирования, будет работать правильно при любых обстоятельствах.
2. Повысить вероятность того, что приложение, предназначенное для тестирования, будет соответствовать всем описанным требованиям.
3. Провести полное тестирование приложения за короткий срок.

Задачи тестирования:
1. Проверить, что система работает в соответствии с определенными временами отклика клиента и сервера.
2. Проверить, что наиболее критические последовательности действий с системой конечного пользователя выполняются верно.
3. Проверить работу пользовательских интерфейсов
4. Проверить, что изменения в базах данных не оказывают неблагоприятного влияния на существующие программные модули.
5. При проектировании тестов свести к минимуму переработку тестов при возможных изменениях приложения.
6. Использовать инструменты автоматизированного тестирования там, где это целесообразно.
7. Проводить тестирование таким образом, чтобы не только обнаруживать, но и предупреждать дефекты.
8. При проектировании автоматизированных тестов использовать стандарты разработки таким образом, чтобы создать многократно используемые и сопровождаемые скрипты.

Принципы тестирования:
Принцип 1 — Тестирование демонстрирует наличие дефектов.
Тестирование только снижает вероятность наличия дефектов, которые находятся в программном обеспечении, но не гарантирует их отсутствия.
Принцип 2 — Исчерпывающее тестирование невозможно.
Полное тестирование с использованием всех входных комбинаций данных, результатов и предусловий физически невыполнимо (исключение — тривиальные случаи).
Принцип 3 — Раннее тестирование.
Следует начинать тестирование на ранних стадиях жизненного цикла разработки ПО, чтобы найти дефекты как можно раньше.
Принцип 4 — Скопление дефектов.
Большая часть дефектов находится в ограниченном количестве модулей.
Принцип 5 — Парадокс пестицида.
Если повторять те же тестовые сценарии снова и снова, в какой-то момент этот набор тестов перестанет выявлять новые дефекты.
Принцип 6 — Тестирование зависит от контекста. 
Тестирование проводится по-разному в зависимости от контекста. 
Например, программное обеспечение, в котором критически важна безопасность, тестируется иначе, чем новостной портал.
Принцип 7 — Заблуждение об отсутствии ошибок. 
Отсутствие найденных дефектов при тестировании не всегда означает готовность продукта к релизу. 
Система должна быть удобна пользователю в использовании и удовлетворять его ожиданиям и потребностям.

Программа, приложение, ПО – это конечный продукт, который помогает решать те или иные проблемы пользователя или продукт используемый в качестве досуга.

Цель приложения:
1. Развлечение – просто отдых
2. Проблема – более серьёзные приложения решающие проблемы пользователя
3. Могут быть и другие цели, но все они в итоге сводятся либо к развлечению либо к решению проблемы 

Основные виды программного обеспечения:
1. Системное - Системное программное обеспечение представляет собой программы, которые необходимы для работы компьютера и компьютерных сетей.
2. Прикладное - Прикладное программное обеспечение необходимо для выполнения определенных пользовательских задач на компьютере. 
Для прикладного ПО используется такое определение, как приложения.
3. Инструментальное - Инструментальное программное обеспечение необходимо для создания других программ. 
С таким видом ПО работают программисты, а сюда можно отнести компиляторы, ассемблеры, компоновщики, библиотеки, интерпретаторы и другие виды приложений.

Техническое требование – это формулировка технических требований заказчика к разрабатываемому продукту

Bug – в классическом понимании это не соответствие в фактического продукта с техническим требованием. Ошибка из за которой программа работает не корректно

Виды багов:
1. Борбаг — легко обнаруживаемый стабильный баг.
2. Гейзенбаг — сложно обнаруживаемый, периодически исчезающий и меняющий свойства баг при попытке его обнаружения.
3. Мандельбаг — баг с очень сложным, хаотичным, поведением.
4. Шрёдинбаг — критическая ошибка, которая не проявляется, пока кто-нибудь на неё не наткнётся в исходном коде, после чего программа совершенно перестаёт работать.

Кто создает программы:
1. Заказчик
2. Аналитик
3. Разработчик
4. Тестировщик

Тестировщик – это не просто специалист проверяющий работу приложений с целью найти в них всевозможные ошибки и уязвимости, его задача предоставить исчерпывающую 
информацию о том как работает продукт. Он может руководствоваться не только документацией, но и здравым смыслом. 
Он смотрит на систему не только глазами разработчика, но и пользователя.

Жизненный цикл ПО. Code and Fix (Проб и ошибок):
ТЗ -> Разработка -> Исправление ошибок -> Готовый продукт
Является первой моделью разработки ПО
Правила этого метода:
1. Получаем техническое требование;
2. Разработка;
3. Передача заказчику на проверку;
4. Получаем обратную связь и вносим корректировки;
5. Цикл повторяется до тех пор, пока заказчик не будет доволен продуктом или пока не закончится бюджет;
Здесь все просто. Пишем только код, нет необходимости планировать, документировать. По этой причине Code and Fix требует минимальной квалификации разработчиков.
В данном подходе Bug-и находятся легко, так как они на поверхности.
Bug-и быстро исправляются.
Но в данном подходе тестировщики могут в принципе отсутствовать. 
А если и есть, то не всегда смогут успеть проверить весь функционал, так как изменения происходят часто и хаотично.

Жизненный цикл ПО. Waterfall (Каскадная модель)
Требования -> Проектирование -> Конструирование -> Воплощение -> Тестирование -> Инсталляция -> Поддержка
В основе метода лежит последовательность шагов, которые должны быть приняты на протяжении жизненного цикла. 
Каждый этап согласовывается компетентными сотрудниками, документируется и передается дальше.
Преимущества каскадной модели:
1. Устойчива к изменению кадрового состава, благодаря подробному документированию. На сроки исполнения проекта почти не влияет;
2. Дисциплина. Исполнители работают в рамках намеченного плана;
3. Гибкость на ранних этапах. Изменения в первых трех фазах могут быть сделаны быстро и с минимальными усилиями, так как кода в принципе еще нет.
4. Ориентация на сроки и финансы. Благодаря тому, что каждый этап полностью очерчивает контур будущего ПО, все разработчики понимают свою роль, 
границы работы и сроки исполнения. Это позволяет оперировать реальными цифрами перед заказчиком, что делает модель проекта привлекательной.
Недостатки каскадной модели:
1. Неадаптивная структура ПО. Если на фазе тестирования выявляются проблемы в общей структуре, то это влечет за собой срыв сроков и даже отказ заказчика;
2. Игнорируют конечного пользователя. Чем ниже продвигается процесс, тем меньше в нем роль заказчика и пользователей. Внесение изменений в функциональность ПО, 
запускает всю цепочку этапов заново. Продукты получаются далеки от ориентации на массового пользователя;
3. Позднее тестирование. Тестирование проходит на поздних этапах, из за этого проблемы невозможно решить фундаментально, только при помощи «костылей»;
Каскадная модель рекомендуется в случаях:
1. Если заказчик требует прозрачность работ и исполнение в назначенные сроки;
2. При наличии в штате руководителей высокой квалификации;
3. При исполнении проекта, не имеющего конкуренции на рынке

Жизненный цикл ПО. V-Образная
Планирование проектов и требований         -> Анализ требований продукта и спецификаций -> Разработка архитектурного проекта на высшем уровне -> Детализированная разработка проекта -> Разработка архитектурного проекта на высшем уровне
Производство, эксплуатация и сопровождение -> Системное и приемочное тестирование       -> Интеграция и тестирование                          -> Модульное тестирование              -> Разработка архитектурного проекта на высшем уровне
V-образная модель – это улучшенная версия классической каскадной модели. 
Здесь на каждом этапе происходит контроль текущего процесса, для того чтобы убедится в возможности перехода на следующий уровень. 
В этой модели тестирование начинается еще со стадии написания требований, причем для каждого последующего этапа предусмотрен свой уровень тестового покрытия.

Жизненный цикл ПО. Итеративная
Do -> Check -> Act -> Plan -> Do
Гибкая модель разработки, основанная на итеративных принципах. Состоит из коротких циклов (1-2 недели). Принципы применений:
1. Наивысший приоритет в удовлетворении потребностей заказчика.
2. На протяжении всего проекта команда и заказчик ежедневно взаимодействуют между собой и друг с другом;
3. Работающий продукт — главный показатель прогресса;
4. Работу можно доверить только само организованной, мотивированной команде;
5. Оптимальные сроки выпуска рабочего продукта — от 2 недель до 2 месяцев;
Преимущества модели:
1. Высокий уровень взаимодействия между членами команды;
2. Быстрый результат (рабочий код) в итоге «спринтов»;
3. Стимулирование изменения и улучшений продукта во время его разработки;
4. Непосредственное вовлечение заказчика к рабочему процессу.
Недостатки модели:
1. Риск бесконечных изменений продукта;
2. Большая зависимость от уровня квалификации и опыта команды;
3. Практически невозможно точно подсчитать итоговую стоимость проекта.
